<html lang="en">
	<head>
	  	<meta charset="UTF-8" />
	  	<title>Water Molecule</title>
	   	<style>
	    	body { margin: 0; }
	  	</style>
		<script src="js/three.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
	 	<script src="js/THREE.MeshLine.js"></script>
		<script src="js/loaders/RGBELoader.js"></script>
		<!--<script src="js/renderers/CanvasRenderer.js"></script>-->
	</head>
	<body>
		<script>
			// ------------------------------------------------
			// BASIC SETUP
			// ------------------------------------------------
			init();
			function init(){
			// Create an empty scene
			var scene = new THREE.Scene();

			// Create a basic perspective camera
			//arg1 = vue proche / loin de l'élément, 
			var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
			camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
			camera.position.z = 100;

			// Create a renderer with Antialiasing
			var renderer = new THREE.WebGLRenderer({antialias:true});

			// Configure renderer size
			renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

			// Append Renderer to DOM
			document.body.appendChild( renderer.domElement );

			/////////////////////////////////////////
			// Shadow
			/////////////////////////////////////////
			/*
			group = new THREE.Group();
			scene.add(group);

							var canvas = document.createElement( 'canvas' );
			canvas.width = 128;
							canvas.height = 128;
							var context = canvas.getContext( '2d' );
							var gradient = context.createRadialGradient(
								canvas.width / 2,
								canvas.height / 2,
								0,
								canvas.width / 2,
								canvas.height / 2,
								canvas.width / 2
							);
							gradient.addColorStop( 0.1, 'rgba(210,210,210,1)' );
							gradient.addColorStop( 1, 'rgba(255,255,255,1)' );
							context.fillStyle = gradient;
							context.fillRect( 0, 0, canvas.width, canvas.height );
							var texture = new THREE.CanvasTexture( canvas );
							var geometry = new THREE.PlaneBufferGeometry( 150, 150, 3, 3 );
							var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );

							var mesh = new THREE.Mesh( geometry, material );
											mesh.position.y = - 50;
											mesh.rotation.x = - Math.PI / 2;
											group.add( mesh );
			*/

			/////////////////////////////////////////
			// Trackball Controller
			/////////////////////////////////////////
			controls = new THREE.TrackballControls(camera);
			controls.rotateSpeed = 5.0;
			controls.zoomSpeed = 3.2;	
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = true;
			controls.staticMoving = false;
			controls.dynamicDampingFactor = 0.2;

			/////////////////////////////////////////
			// TEXTURES
			/////////////////////////////////////////
			/*	var textureLoader = new THREE.TextureLoader();
			var texture = textureLoader.load( "textures/bleu.jpg" );
			texture.repeat.set( 20, 10 );
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.format = THREE.RGBFormat;

			var loader = new THREE.TextureLoader();
			loader.load( 'textures/bleu.jpg', function ( texture ) {

			var geometry = new THREE.SphereGeometry( 5, 52, 32 );

			var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );
			var mesh = new THREE.Mesh( geometry, material );
			group.add( mesh );
			} );
			var alphaMap = new THREE.TextureLoader().load('textures/gris.jpg');
			*/

			/////////////////////////////////////////
			//Sphères
			/////////////////////////////////////////
			//renderer.gammaInput = true;
			//renderer.gammaOutput = true;
			var geometry = new THREE.SphereGeometry( 5, 52, 32 );

			var rouge = new THREE.Color( "#d30606" );
			var materialRed = new THREE.MeshLambertMaterial( {color: rouge.getHex()} );

			var blanc = new THREE.Color( "#ffffff" );
			var materialWhite = new THREE.MeshLambertMaterial( {color: blanc.getHex()} );

			var sphere = new THREE.Mesh( geometry, materialWhite );
			sphere.position.y = 0;
			sphere.position.x = - 15;
			scene.add( sphere );

			var sphere = new THREE.Mesh( geometry, materialWhite );
			sphere.position.y = 0;
			sphere.position.x = 15;
			scene.add( sphere );

			var sphere = new THREE.Mesh( geometry, materialRed );
			sphere.position.y = 10;
			sphere.position.x = 0;
			scene.add( sphere );

			/////////////////////////////////////////
			//Light
			/////////////////////////////////////////
			var light = new THREE.PointLight( 0xFFFFFF , 1.5);
			light.position.set( 10, 0, 80 );
			scene.add(light);

			var light = new THREE.PointLight( 0xFFFFFF , 1.5);
			light.position.set( 25, 0, -80 );
			scene.add(light);
			//sphere.material.wireframe=true;

			/////////////////////////////////////////
			//Lignes
			/////////////////////////////////////////
			var gris = new THREE.Color( "#c4c0c0" );
			//var gris = new THREE.Color("rgb(672, 637, 585)");
			var material = new THREE.LineBasicMaterial({color: gris.getHex(), linewidth: 1});

			var geometry = new THREE.Geometry();
			geometry.vertices.push(
				new THREE.Vector3( -15, 0, 0 ),
				new THREE.Vector3( 0, 10, 0 ),
				new THREE.Vector3( 15, 0, 0 )
			);

			var line = new THREE.Line( geometry, material );
			scene.add( line );

			var light = new THREE.PointLight( 0x00000, 1, 100 );
			light.position.set( 0, 0, 0 );
			scene.add( light );

			/////////////////////////////////////////
			//TrackbackControll function
			/////////////////////////////////////////
			function renderObj() {
			  renderer.render( scene, camera );
			}

			// Render the scene when the controls have changed.
			// If you don’t have other animations or changes in your scene,
			// you won’t be draining system resources every frame to render a scene.
			controls.addEventListener( 'change', renderObj );

			// Avoid constantly rendering the scene by only 
			// updating the controls every requestAnimationFrame
			function animationLoop() {
			  requestAnimationFrame(animationLoop);
			  controls.update();
			}
			animationLoop();

			/////////////////////////////////////////
			//Window Resizablefunction
			/////////////////////////////////////////
			window.addEventListener( 'resize', onWindowResize, false );
			function onWindowResize() {
							windowHalfX = window.innerWidth / 2;
							windowHalfY = window.innerHeight / 2;
							camera.aspect = window.innerWidth / window.innerHeight;
							camera.updateProjectionMatrix();
							renderer.setSize( window.innerWidth, window.innerHeight );
						}
			}
		</script>
	</body>
</html>